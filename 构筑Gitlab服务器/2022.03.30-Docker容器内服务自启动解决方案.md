## Docker容器内服务自启动解决方案

### 目录

- [Docker容器内服务自启动解决方案](#docker容器内服务自启动解决方案)
  - [目录](#目录)
  - [1、先将容器保存为镜像](#1先将容器保存为镜像)
  - [2、编写服务启动shell脚本（run.sh）](#2编写服务启动shell脚本runsh)
  - [3、编写Dockerfile文件](#3编写dockerfile文件)
  - [4、重新构建lamp镜像](#4重新构建lamp镜像)
  - [5、使用重新构建的镜像启动容器](#5使用重新构建的镜像启动容器)
  - [6、进入容器查看Apache和mysql进程，正常情况下，服务是已经自启动了](#6进入容器查看apache和mysql进程正常情况下服务是已经自启动了)
  - [Memo](#memo)

背景
在很多场景下，我们需要拉取或者是使用的别人的容器，但是有些容器内部的服务并不能自启动，比如Apache服务、mysql服务等等，对于数量较少的容器来讲，我们可以进入容器中使用命令将服务进行启动，但是如果是在一些像是CTF竞赛场景下，需要启动几十个或者是上百个docker容器，这个时候，如果容器内服务不能自启动，对于赛事运维运维人员来讲便是一场噩梦。那么怎么解决这个问题呢？

解决方案
我们来想一下，要解决服务不能自启这个问题，其实跟我们手动起执行命令启动容器原理差不多，只不过这个时候就不能我们手动起了，要给容器或者是镜像写一个shell，让它在容器启动的时候自动执行命令去启动服务。

实施（案例:以lamp为例）

### 1、先将容器保存为镜像

```bash
# 查看容器id及其状态
docker ps -a


# 若容器状态为running，需停止容器
docker stop <容器id>                    ---- docker stop 6ave5f37f835

# 将容器打包成镜像
docker commit <容器id> <镜像名>:<tag>       ---- docker commit 6ave5f37f835 lamp:v1

# 查看保存下来的镜像
docker images
```

### 2、编写服务启动shell脚本（run.sh）

```bash
#!/bin/bash
sleep 1
service apache2 start
service mysql start
```

 ### 3、编写Dockerfile文件

```bash
FROM lamp:v1      # 在第一步保存下来的镜像
COPY run.sh /var/www/html/run.sh
RUN chmod +x /var/www/html/run.sh
WORKDIR /var/www/html
ENTRYPOINT /var/www/html/run.sh && tail -f /dev/null
```

### 4、重新构建lamp镜像

```bash
docker build -t lamp:latest . 
```

### 5、使用重新构建的镜像启动容器

```bash
docker run -itd -p 8888:80 -p 2222:22 --restart=always lamp:latest
```

### 6、进入容器查看Apache和mysql进程，正常情况下，服务是已经自启动了

```bash
docker exec -it <容器id> /bin/bash       # 进入容器

ps -ef | grep apache2
ps -ef | grep mysql 
```

### Memo

```bash
/usr/local/sbin

#!/bin/bash
sleep 1
postfix start


FROM ubuntu:V1
COPY run.sh /usr/local/sbin/run.sh
RUN chmod +x /usr/local/sbin/run.sh
WORKDIR /usr/local/sbin
ENTRYPOINT /usr/local/sbin/run.sh && tail -f /dev/null


docker build -t ubuntu:V2 .

docker run -itd -p 8888:80 -p 2222:22 --restart=always ubuntu:V2

```

